/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/ 		if(executeModules) {
/******/ 			for(i=0; i < executeModules.length; i++) {
/******/ 				result = __webpack_require__(__webpack_require__.s = executeModules[i]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		1: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
//渲染
var Render = function () {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
        window.setTimeout(callback, 1000 / 60);
    };
}();

exports.default = Render;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _stage = __webpack_require__(6);

var _stage2 = _interopRequireDefault(_stage);

var _chart = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var miniChart = function () {
    function miniChart(container) {
        _classCallCheck(this, miniChart);

        //版本
        this.version = '1.0';

        this.container = container;
    }

    _createClass(miniChart, [{
        key: 'setOption',
        value: function setOption(option) {

            var stage2d = new _stage2.default(this.container);

            //创建一个前景场景对象，用于绘制饼图
            //let foregroundScene = stage2d.createScene("foreground")

            //创建一个背景场景对象，用于绘制坐标轴，图例等只需绘制一次的内容
            //let backdropScene = stage2d.createScene("backdrop")

            //创建一个饼状图图表，传入配置信息
            var chartPie2d = new _chart.ChartPie(option);

            stage2d.addChart(chartPie2d);

            stage2d.startPaint();

            //将饼状图绑定到前景场景对象
            //foregroundScene.addChart(chartPie2d)

            //将饼状图绑定到背景场景对象
            //backdropScene.addChart(chartPie2d)


            // let chart2d = new Chart(option, stage2d)
            // chart2d.startPaint()
        }

        /*!
         * [init 初始化图表]
         * @return {[Object]} [图表句柄]
         */
        /*!
         * [init description]
         * @param  {[type]} element [description]
         * @return {[type]}         [description]
         */

    }], [{
        key: 'init',
        value: function init(container) {
            return new miniChart(container);
        }
    }]);

    return miniChart;
}();

exports.default = miniChart;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ChartPie = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //引入工具函数


//引入渲染优化方法


//引入工具函数


var _tool = __webpack_require__(3);

var _render = __webpack_require__(0);

var _render2 = _interopRequireDefault(_render);

var _shape = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//图表默认配置信息

var colors = ['#fa5a64', '#1bbc9b', '#f48804', '#eb41a0', '#f1c40f', '#c3d72d', '#32c5d2', '#50d2fa', '#c87846', '#6e37e6', '#8c50c8'];

//
// NOTE: chart 对象类似导演，通过舞台布置场景

var ChartPie = exports.ChartPie = function () {
	function ChartPie(option) {
		_classCallCheck(this, ChartPie);

		this.option = option;

		this.stage2d = null;

		this.type = option.type;

		//图例
		this.legend = '';

		//图形列表
		this.shapeList = [];

		this.option = option;
	}

	_createClass(ChartPie, [{
		key: 'init',
		value: function init(stage2d) {
			//将图表绑定到场景实例
			this.stage2d = stage2d;

			//创建一个背景场景对象，用于绘制坐标轴，图例等只需绘制一次的内容
			this.backdropScene = stage2d.createScene("backdrop");

			//创建一个前景场景对象，用于绘制饼图
			this.foregroundScene = stage2d.createScene("foreground");

			this.setPie();
		}
	}, {
		key: 'setPie',
		value: function setPie() {
			var _this = this;

			var option = this.option;

			var stage2d = this.stage2d;

			//计算半径
			var radius = Math.min(stage2d.width, stage2d.height) / 2 * parseInt(option.radius.slice(0, -1)) / 100;

			//计算饼的圆心坐标
			var centerX = stage2d.width * parseInt(option.center[0].slice(0, -1)) / 100;
			var centerY = stage2d.height * parseInt(option.center[1].slice(0, -1)) / 100;

			//计算饼图百分比
			if (Array.isArray(option.data) && option.data.length > 0) {

				var list = option.data;

				//总计
				var total = 0;

				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var v = _step.value;

						total += v.value;
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				var sAngle = 0,
				    eAngle = 0;

				var shapeList = list.map(function (v, i) {

					var shape = new _shape.Pie();

					// 饼形图
					shape.stage2d = _this.stage2d;
					shape.x = centerX;
					shape.y = centerY;
					shape.pattern = colors[i];
					shape.mouseOverPattern = (0, _tool.lighten)(colors[i]);
					shape.name = v.name;
					shape.value = v.value;
					shape.radius = radius;
					shape.precent = v.value / total * 100;

					eAngle += shape.precent / 50 * Math.PI;

					shape.sAngle = sAngle;
					shape.eAngle = sAngle;

					sAngle = eAngle;

					shape.animate({
						eAngle: eAngle
					});

					return shape;
				});

				this.shapeList = shapeList;
			}
		}

		//前景绘制（图表）

	}, {
		key: 'foregroundPaint',
		value: function foregroundPaint(scene) {
			var _this2 = this;

			this.foregroundScene.paint(function (context) {

				_this2.shapeList.forEach(function (shape) {
					shape.paint(context);
				});
			});
		}

		//背景绘制 （坐标轴，图例等）

	}, {
		key: 'backdropPaint',
		value: function backdropPaint(scene) {}
	}]);

	return ChartPie;
}();

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.offsetTop = offsetTop;
exports.offsetLeft = offsetLeft;
exports.lighten = lighten;
exports.darken = darken;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//获取元素相对于窗口左边的距离
function offsetTop(elements) {
    var top = elements.offsetTop;
    var parent = elements.offsetParent;
    while (parent != null) {
        top += parent.offsetTop;
        parent = parent.offsetParent;
    }
    return top;
}

//获取元素相对于窗口顶端边的距离
function offsetLeft(elements) {
    var left = elements.offsetLeft;
    var parent = elements.offsetParent;
    while (parent != null) {
        left += parent.offsetLeft;
        parent = parent.offsetParent;
    }
    return left;
}

//防抖和节流

var throttler = function () {
    function throttler() {
        var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        _classCallCheck(this, throttler);

        this.delay = delay;
        this.lastTime = new Date().getTime();
    }

    _createClass(throttler, [{
        key: "throttle",
        value: function throttle(fn) {
            var currentTime = new Date().getTime();
            if (currentTime - this.lastTime > this.delay) {
                console.log(currentTime - this.lastTime, this.delay);
                this.lastTime = currentTime;
                fn();
            }
        }
    }], [{
        key: "delay",
        value: function delay(_delay) {
            return new throttler(_delay);
        }
    }]);

    return throttler;
}();

exports.throttler = throttler;


function rgbToHex(r, g, b) {
    var hex = (r << 16 | g << 8 | b).toString(16);
    return "#" + new Array(Math.abs(hex.length - 7)).join("0") + hex;
}

function hexToRgb(hex) {
    var rgb = [];
    for (var i = 1; i < 7; i += 2) {
        rgb.push(parseInt("0x" + hex.slice(i, i + 2)));
    }
    return rgb;
}

function lighten(hex) {
    var rgb = hexToRgb(hex);
    var arr = rgb.map(function (v) {
        return Math.min(v + 10, 255);
    });
    console.log(rgbToHex(arr[0], arr[1], arr[2]));
    return rgbToHex(arr[0], arr[1], arr[2]);
}

function darken(hex) {
    var rgb = hexToRgb(hex);
    var arr = rgb.map(function (v) {
        return Math.max(v - 10, 0);
    });
    return rgbToHex(arr[0], arr[1], arr[2]);
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(5);
module.exports = __webpack_require__(1);


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * HiDPI Canvas Polyfill (1.0.10)
 *
 * Author: Jonathan D. Johnson (http://jondavidjohn.com)
 * Homepage: https://github.com/jondavidjohn/hidpi-canvas-polyfill
 * Issue Tracker: https://github.com/jondavidjohn/hidpi-canvas-polyfill/issues
 * License: Apache-2.0
*/
(function (prototype) {

	var pixelRatio = function () {
		var canvas = document.createElement('canvas'),
		    context = canvas.getContext('2d'),
		    backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

		return (window.devicePixelRatio || 1) / backingStore;
	}(),
	    forEach = function forEach(obj, func) {
		for (var p in obj) {
			if (obj.hasOwnProperty(p)) {
				func(obj[p], p);
			}
		}
	},
	    ratioArgs = {
		'fillRect': 'all',
		'clearRect': 'all',
		'strokeRect': 'all',
		'moveTo': 'all',
		'lineTo': 'all',
		'arc': [0, 1, 2],
		'arcTo': 'all',
		'bezierCurveTo': 'all',
		'isPointinPath': 'all',
		'isPointinStroke': 'all',
		'quadraticCurveTo': 'all',
		'rect': 'all',
		'translate': 'all',
		'createRadialGradient': 'all',
		'createLinearGradient': 'all'
	};

	if (pixelRatio === 1) return;

	forEach(ratioArgs, function (value, key) {
		prototype[key] = function (_super) {
			return function () {
				var i,
				    len,
				    args = Array.prototype.slice.call(arguments);

				if (value === 'all') {
					args = args.map(function (a) {
						return a * pixelRatio;
					});
				} else if (Array.isArray(value)) {
					for (i = 0, len = value.length; i < len; i++) {
						args[value[i]] *= pixelRatio;
					}
				}

				return _super.apply(this, args);
			};
		}(prototype[key]);
	});

	// Stroke lineWidth adjustment
	prototype.stroke = function (_super) {
		return function () {
			this.lineWidth *= pixelRatio;
			_super.apply(this, arguments);
			this.lineWidth /= pixelRatio;
		};
	}(prototype.stroke);

	// Text
	//
	prototype.fillText = function (_super) {
		return function () {
			var args = Array.prototype.slice.call(arguments);

			args[1] *= pixelRatio; // x
			args[2] *= pixelRatio; // y

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m * pixelRatio + u;
			});

			_super.apply(this, args);

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m / pixelRatio + u;
			});
		};
	}(prototype.fillText);

	prototype.strokeText = function (_super) {
		return function () {
			var args = Array.prototype.slice.call(arguments);

			args[1] *= pixelRatio; // x
			args[2] *= pixelRatio; // y

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m * pixelRatio + u;
			});

			_super.apply(this, args);

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m / pixelRatio + u;
			});
		};
	}(prototype.strokeText);
	window.pixelRatio = pixelRatio;
})(CanvasRenderingContext2D.prototype);
;(function (prototype) {
	prototype.getContext = function (_super) {
		return function (type) {
			var backingStore,
			    ratio,
			    context = _super.call(this, type);

			if (type === '2d') {

				backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

				ratio = (window.devicePixelRatio || 1) / backingStore;

				if (ratio > 1) {
					this.style.height = this.height + 'px';
					this.style.width = this.width + 'px';
					this.width *= ratio;
					this.height *= ratio;
				}
			}

			return context;
		};
	}(prototype.getContext);
})(HTMLCanvasElement.prototype);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //引入渲染优化方法


//引入场景对象


//引入图表对象


//引入事件对象


//引入常量名


var _render = __webpack_require__(0);

var _render2 = _interopRequireDefault(_render);

var _scene = __webpack_require__(7);

var _scene2 = _interopRequireDefault(_scene);

var _chart = __webpack_require__(2);

var _chart2 = _interopRequireDefault(_chart);

var _event = __webpack_require__(9);

var _constants = __webpack_require__(10);

var _tool = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lastIDOMHighResTimeStamp = 0;

//引入工具函数


//last iDOMHighResTimeStamp
var lastTimestamp = 0;

//舞台

var Stage = function () {
    function Stage(container) {
        var _this = this;

        _classCallCheck(this, Stage);

        //容器, canvas 元素的 parent
        this.container = container;

        this.container.style.position = 'relative';

        //前景容器
        //this.foregroundList = []

        //背景容器
        //this.backdropList = []

        //图表容器
        this.chartList = [];

        //舞台的宽和高，既是容器的宽和高，实际也是canvas的宽和高
        this.width = container.clientWidth;
        this.height = container.clientHeight;

        //获取舞台相对于当前视窗的偏移，实际上也是canvas相对于当前视窗的偏移
        this.offset = {
            top: (0, _tool.offsetTop)(container),
            left: (0, _tool.offsetLeft)(container)

            //侦听器容器
        };this.eventlist = [];

        //当前舞台的缩放
        this.scale = 1;

        //当前舞台的偏移
        this.translateX = 0;
        this.translateY = 0;

        this.pixelRatio = pixelRatio;

        console.log("windowRatio", this.ratio);

        //鼠标X
        this.mouseX = 0;

        //鼠标Y
        this.mouseY = 0;

        //鼠标X
        this.mouseClickX = 0;

        //鼠标Y
        this.mouseClickY = 0;

        //鼠标相对于页面X
        this.pageX = 0;

        //鼠标相对于页面Y
        this.pageY = 0;

        //当前帧距离上一帧的时间间隔
        this.interval = 0;

        //等待播放动画元素的个数
        this.animaterNumber = 0;

        //添加事件监听
        document.addEventListener("mouseup", function (e) {
            //coreStage2d.stageMouseUp(e)
        }, false);

        container.addEventListener("mousedown", function (e) {
            //coreStage2d.stageMouseDown(e)
        }, false);

        container.addEventListener("mousemove", function (e) {
            _this.pageX = e.pageX;
            _this.pageY = e.pageY;
            _this.mouseX = (e.pageX - _this.offset.left) * _this.pixelRatio;
            _this.mouseY = (e.pageY - _this.offset.top) * _this.pixelRatio;
        }, false);

        //缩放事件
        container.addEventListener("DOMMouseScroll", function (e) {
            //缩放，暂时禁用
            //this.stageScroll(e)
        }, false);
        //兼容FF
        container.onmousewheel = function (e) {
            //缩放，暂时禁用
            //this.stageScroll(e)
        };
    }

    //动画更新逻辑，计算属性的过渡值


    _createClass(Stage, [{
        key: 'update',
        value: function update(shape) {
            var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;


            var props = shape.change;

            shape.time += 16;

            if (shape.time > speed) {
                shape.time = speed;
            }

            for (var prop in props) {

                if (prop === 'eAngle') {
                    //通过缓动函数求出某一属性在时间轴上对应的过度值
                    shape[prop] = this.easeOut(shape.time / 1000, shape[prop], shape.change[prop], speed);
                } else {
                    //通过缓动函数求出某一属性在时间轴上对应的过度值
                    shape[prop] = this.easeOut(shape.time / 1000, shape[prop], shape.change[prop], speed);
                }
            }
        }

        /*!
         * [easeOut 缓动函数]
         * @param  {[float]} t:timestamp [动画执行到当前帧所经过的时间] 如：0.3s
         * @param  {[float]} b:begining [起始值] 如：10
         * @param  {[float]} c:change [需要变化的量] 如：从 10 到 100，变化量是 90
         * @param  {[float]} d:duration [动画从开始到结束的总时长] 如：0.4s
         * @return {[float]}   [description] 时间轴上对应的过度值
         */

    }, {
        key: 'easeOut',
        value: function easeOut(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        }

        //创建一个场景

    }, {
        key: 'createScene',
        value: function createScene(type) {
            //初始化一个场景，并绑定当前舞台
            var scener = _scene2.default.init(this);

            return scener;
        }

        //添加一个图表

    }, {
        key: 'addChart',
        value: function addChart(chart) {
            chart.init(this);
            this.chartList.push(chart);

            // switch (chart.type) {
            //     case "pie":
            //         chart.
            //         break;
            //     default:
            //
            // }
        }
    }, {
        key: 'stageScroll',
        value: function stageScroll(e) {

            //判定鼠标指针在画布内
            if (Math.abs(e.pageX) > this.offset.left && Math.abs(e.pageX) < this.offset.left + this.width && Math.abs(e.pageY) > this.offset.top && Math.abs(e.pageY) < this.offset.top + this.height) {
                //阻止冒泡
                e.preventDefault();

                //计算出缩放前的鼠标在场景中的 X、Y
                var beforeX = (e.pageX - this.offset.left - this.translateX) / this.scale,
                    beforeY = (e.pageY - this.offset.top - this.translateY) / this.scale;

                if (e.detail > 0 || e.wheelDelta < 0) {
                    if (this.scale > 0.2) this.scale -= .1;
                } else {
                    if (this.scale < 4) this.scale += .1;
                }

                this.translateX = -beforeX * this.scale + (e.pageX - this.offset.left);
                this.translateY = -beforeY * this.scale + (e.pageY - this.offset.top);
            }

            console.log(this.scale);
        }
    }, {
        key: 'paint',
        value: function paint() {}

        //背景绘制

    }, {
        key: 'backdropPaint',
        value: function backdropPaint() {
            this.chartList.forEach(function (scener) {

                // this.chartList.forEach((chart2d) => {
                //     chart.paintBackdrop()
                // })
            });
        }

        //前景绘制

    }, {
        key: 'foregroundPaint',
        value: function foregroundPaint() {
            var _this2 = this;

            this.chartList.forEach(function (chart) {
                chart.foregroundPaint();
            });

            //此处计算 this.interval


            //DOMHighResTimeStamp 是一个double类型，用于存储时间值。该值可以是离散的时间点或两个离散时间点之间的时间差，单位为毫秒
            (0, _render2.default)(function (iDOMHighResTimeStamp) {
                //计算每次绘制的时间间隔
                _this2.interval = iDOMHighResTimeStamp - lastTimestamp;
                lastTimestamp = iDOMHighResTimeStamp;
                _this2.foregroundPaint();
            });
        }

        //开始绘制

    }, {
        key: 'startPaint',
        value: function startPaint() {
            var _this3 = this;

            (0, _render2.default)(function (iDOMHighResTimeStamp) {

                //计算每次绘制的时间间隔
                _this3.interval = iDOMHighResTimeStamp - lastTimestamp;
                lastTimestamp = iDOMHighResTimeStamp;

                //背景只绘制一次
                _this3.backdropPaint();

                //前景一般需要重复绘制
                _this3.foregroundPaint();
            });
        }
    }]);

    return Stage;
}();

exports.default = Stage;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
      value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //引入渲染优化方法


var _render = __webpack_require__(0);

var _render2 = _interopRequireDefault(_render);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//场景
var Scene = function () {
      function Scene(stage2d, canvas) {
            _classCallCheck(this, Scene);

            //场景对应的舞台
            this.stage2d = stage2d;

            this.width = stage2d.width;

            this.height = stage2d.height;

            //图表容器
            this.chartList = [];

            //场景画布对象
            this.canvas = canvas;

            //绘图对象
            this.context = canvas.getContext('2d');

            //重复绘制开关
            this.repaintSwitch = false;
      }

      //添加图表


      _createClass(Scene, [{
            key: 'addChart',
            value: function addChart(chart2d) {
                  this.chartList.push(chart2d);
            }

            //

      }, {
            key: 'setRePaint',
            value: function setRePaint(isOnOff) {
                  this.repaintSwitch = isOnOff === 'off' ? false : true;
            }

            //重绘核心

      }, {
            key: 'repaint',
            value: function repaint() {

                  //清理画面
                  this.context.clearRect(0, 0, this.width, this.height);

                  //重置画布的透明度
                  this.context.globalAlpha = 1;

                  this.context.save();

                  //重新设定画布偏移和缩放
                  this.context.translate(this.stage2d.translateX, this.stage2d.translateY);

                  // console.log("this.scale", this.scale);
                  this.context.scale(this.stage2d.scale, this.stage2d.scale);

                  //需要重复绘制的内容
                  this.chartList.paintForeground();

                  context.restore();

                  //判断重绘开关状态，一般当动画更新完成后，将关闭重绘
                  // if (this.repaintSwitch) {
                  //     //重绘
                  //     Render(() => {
                  //         this.repaint()
                  //     })
                  // }
            }
      }, {
            key: 'paint',
            value: function paint(callback) {
                  //清理画面
                  this.context.clearRect(0, 0, this.width, this.height);

                  //重置画布的透明度
                  this.context.globalAlpha = 1;

                  this.context.save();

                  //重新设定画布偏移和缩放
                  this.context.translate(this.stage2d.translateX, this.stage2d.translateY);

                  // console.log("this.scale", this.scale);
                  this.context.scale(this.stage2d.scale, this.stage2d.scale);

                  //需要重复绘制的内容
                  callback(this.context);

                  this.context.restore();
            }
      }, {
            key: 'oncePaint',
            value: function oncePaint() {
                  //清理画面
                  this.context.clearRect(0, 0, this.width, this.height);

                  //重置画布的透明度
                  this.context.globalAlpha = 1;

                  this.context.save();

                  //重新设定画布偏移和缩放
                  this.context.translate(this.stage2d.translateX, this.stage2d.translateY);

                  // console.log("this.scale", this.scale);
                  this.context.scale(this.stage2d.scale, this.stage2d.scale);

                  //只需要一次绘制的内容
                  this.chartList.paintBackdrop();

                  context.restore();
            }
      }], [{
            key: 'init',
            value: function init(stage2d, index) {

                  //创建 Canvas，并添加到场景
                  var canvas = document.createElement('canvas');
                  canvas.width = stage2d.width;
                  canvas.height = stage2d.height;
                  canvas.style.position = 'absolute';

                  stage2d.container.appendChild(canvas);

                  return new Scene(stage2d, canvas);
            }
      }]);

      return Scene;
}();

exports.default = Scene;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Pie = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _render = __webpack_require__(0);

var _render2 = _interopRequireDefault(_render);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//饼状图
var Pie = exports.Pie = function () {
    function Pie() {
        _classCallCheck(this, Pie);

        //类型
        this.type = 'pie';

        //形状的X坐标
        this.x = 0;

        //形状的Y坐标
        this.y = 0;

        //填充颜色或图案
        this.pattern = '#ffffff';

        //填充颜色或图案 mouseover
        this.mouseOverPattern = '#ffffff';

        //名称
        this.name = '';

        //值
        this.value = 0;

        //半径
        this.radius = 0;

        //百分比
        this.precent = 0;

        //起始角，以弧度计
        this.sAngle = 0;

        //结束角，以弧度计
        this.eAngle = 0;

        //动画更新开关
        this.animationSwitch = false;

        //动画变化量
        //changeValue = {}

        //动画时间轴
        //this.time = 0
    }

    //配置过渡动画


    _createClass(Pie, [{
        key: 'animate',
        value: function animate(option) {
            var _this = this;

            var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;


            //属性原始值
            var originalValues = {};

            //属性变化量
            var changeValues = {};

            for (var key in option) {
                if (key === 'eAngle') {
                    originalValues[key] = this[key] * 100;
                    changeValues[key] = option[key] * 100 - originalValues[key];
                } else {
                    originalValues[key] = this[key];
                    changeValues[key] = option[key] - this[key];
                }
            }

            var time = 0;

            var durationTime = speed / 1000;

            var step = function step() {

                time = time + _this.stage2d.interval;

                if (time > speed) {
                    time = speed;
                }

                for (var _key in changeValues) {

                    if (_key === 'eAngle') {
                        //通过缓动函数求出某一属性在时间轴上对应的过度值
                        _this[_key] = _this.easeOut(time / 1000, originalValues[_key], changeValues[_key], durationTime) / 100;
                    } else {
                        //通过缓动函数求出某一属性在时间轴上对应的过度值
                        _this[_key] = _this.easeOut(time / 1000, originalValues[_key], changeValues[_key], durationTime);
                    }

                    // console.table([
                    //     {
                    //         time,
                    //         originalValue: originalValues[key],
                    //         changeValue: changeValues[key],
                    //         speed,
                    //         value: this[key],
                    //         eAngel: option[key] * 100
                    //     }
                    // ])
                }

                if (time < speed) {
                    (0, _render2.default)(step);
                }
            };

            (0, _render2.default)(step);
        }

        /*!
         * [easeOut 缓动函数]
         * @param  {[float]} t:timestamp [动画执行到当前帧所经过的时间] 如：0.3s
         * @param  {[float]} b:begining [起始值] 如：10
         * @param  {[float]} c:change [需要变化的量] 如：从 10 到 100，变化量是 90
         * @param  {[float]} d:duration [动画从开始到结束的总时长] 如：0.4s
         * @return {[float]}   [description] 时间轴上对应的过度值
         */

    }, {
        key: 'easeOut',
        value: function easeOut(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        }

        //绘制饼形

    }, {
        key: 'paintPie',
        value: function paintPie(context) {

            context.beginPath();

            //对于饼状图，xy是圆的中心
            context.moveTo(this.x, this.y);

            context.arc(this.x, this.y, this.radius, this.sAngle, this.eAngle);

            context.closePath();

            if (context.isPointInPath(this.stage2d.mouseX, this.stage2d.mouseY)) {
                context.fillStyle = this.mouseOverPattern;
            } else {
                context.fillStyle = this.pattern;
            }

            context.fill();

            context.stroke();
        }

        //绘制名称

    }, {
        key: 'paintName',
        value: function paintName(context, stage2d) {}
    }, {
        key: 'paint',
        value: function paint(context) {

            //动画更新
            //this.stage2d.update(this)

            //绘制饼形
            context.save();

            context.strokeStyle = "#fdfdfd";
            context.lineJoin = "bevel";

            context.fillText("Hello World!", 10, 50);

            this.paintPie(context);

            context.restore();
        }
    }]);

    return Pie;
}();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Event = Event;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//事件对象
var event2D = function event2D(event, callback) {
    _classCallCheck(this, event2D);

    //事件类型
    this.event = event;

    //事件回调
    this.callback = callback;
};

//添加事件


function Event(event, callback) {
    return new event2D(event, callback);
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//鼠标按下事件
var EVENT_MOUSE_DOWN = exports.EVENT_MOUSE_DOWN = "EVENT_MOUSE_DOWN";

//鼠标移动事件
var EVENT_MOUSE_MOVE = exports.EVENT_MOUSE_MOVE = "EVENT_MOUSE_MOVE";

//鼠标松开事件
var EVENT_MOUSE_UP = exports.EVENT_MOUSE_UP = "EVENT_MOUSE_UP";

//鼠标松开事件
var EVENT_MOUSE_SCROLL = exports.EVENT_MOUSE_SCROLL = "EVENT_MOUSE_SCROLL";

/***/ })
/******/ ]);