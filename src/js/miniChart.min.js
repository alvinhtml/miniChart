/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/ 		if(executeModules) {
/******/ 			for(i=0; i < executeModules.length; i++) {
/******/ 				result = __webpack_require__(__webpack_require__.s = executeModules[i]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		1: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _stage = __webpack_require__(6);

var _stage2 = _interopRequireDefault(_stage);

var _chart = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var miniChart = function () {
    function miniChart(container) {
        _classCallCheck(this, miniChart);

        //版本
        this.version = '1.0';

        this.container = container;

        this.chartList = [];
    }

    _createClass(miniChart, [{
        key: 'setOption',
        value: function setOption(option) {

            var stage2d = new _stage2.default(this.container);

            //创建一个饼状图图表，传入配置信息
            var chartPie2d = new _chart.ChartPie(option);

            this.chartList.push(chartPie2d);

            stage2d.addChart(chartPie2d);

            stage2d.startPaint();
        }

        //绑定事件

    }, {
        key: 'addEventListener',
        value: function addEventListener(event, callback) {
            this.chartList.forEach(function (chart) {
                chart.addEventListener(event, callback);
            });
        }

        //开启 tips

    }, {
        key: 'tip',
        value: function tip(format) {
            this.chartList.forEach(function (chart) {
                chart.addTip(format);
            });
        }

        /*!
         * [init 初始化图表]
         * @return {[Object]} [图表句柄]
         */
        /*!
         * [init description]
         * @param  {[type]} element [description]
         * @return {[type]}         [description]
         */

    }], [{
        key: 'init',
        value: function init(container) {
            return new miniChart(container);
        }
    }]);

    return miniChart;
}();

exports.default = miniChart;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
//渲染
var Render = function () {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
        window.setTimeout(callback, 1000 / 60);
    };
}();

exports.default = Render;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ChartPie = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //引入工具函数


//引入事件对象


//引入事件对象


//引入工具函数


var _tool = __webpack_require__(3);

var _event = __webpack_require__(8);

var _event2 = _interopRequireDefault(_event);

var _tip = __webpack_require__(9);

var _tip2 = _interopRequireDefault(_tip);

var _shape = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//图表默认配置信息

// const colors = [
// 	'#fa5a64',
// 	'#1bbc9b',
// 	'#f48804',
// 	'#eb41a0',
// 	'#f1c40f',
// 	'#c3d72d',
// 	'#32c5d2',
// 	'#50d2fa',
// 	'#c87846',
// 	'#6e37e6',
// 	'#8c50c8',
// ]

// NOTE: chart 对象类似导演，通过舞台布置场景


var Chart = function () {
	function Chart(option) {
		_classCallCheck(this, Chart);

		//图表配置数据
		this.option = option;

		this.stage2d = null;

		this.type = option.type;

		//图例
		this.legendList = [];

		//图形列表
		this.shapeList = [];

		//事件列表
		this.eventList = [];

		//需要复原的动画
		this.recoverAnimateList = [];

		//默认样式配置信息
		this.style = {
			colors: ['#f2711c', '#fbbd08', '#b5cc18', '#21ba45', '#00b5ad', '#2185d0', '#6435c9', '#a333c8', '#e03997', '#a5673f'],
			font: '12px sans-serif',
			legend: null,
			nameStyle: null,
			valueStyle: '{c}%'

			//图例Y轴偏移
		};this.legendOffsetTop = 20;

		this.tip = null;
	}

	_createClass(Chart, [{
		key: 'init',
		value: function init(stage2d) {
			//将图表绑定到场景实例
			this.stage2d = stage2d;

			//创建一个背景场景对象，用于绘制坐标轴，图例等只需绘制一次的内容
			this.backdropScene = stage2d.createScene();

			//创建一个前景场景对象，用于绘制饼图
			this.foregroundScene = stage2d.createScene();

			//配置信息
			if (typeof this.option.style !== 'undefined') {
				Object.assign(this.style, this.option.style);
			}

			//图例位置
			if (this.style.legend === 'top') {
				this.legendOffsetTop = 20;
			} else if (this.style.legend === 'bottom') {
				this.legendOffsetTop = stage2d.height - 20;
			}

			this.initOptions();
		}

		//


		//添加一个等待复原的动画

	}, {
		key: 'addRecoverAnimate',
		value: function addRecoverAnimate(shape, option) {
			this.recoverAnimateList.push({
				shape: shape,
				option: option
			});
		}

		//复原的动画

	}, {
		key: 'recoverAnimate',
		value: function recoverAnimate(shape, option) {
			this.recoverAnimateList.forEach(function (v) {
				v.shape.animate(v.option);
			});
		}

		//初始化图例信息

	}, {
		key: 'initLegend',
		value: function initLegend() {
			var _this = this;

			if (!this.style.legend) return false;

			//图例分段， 用于实现图例换行
			var legendSection = [];
			var offsetLeft = 0;
			this.option.legend.forEach(function (v, i) {

				//图例名称的绘制宽度
				var width = parseInt(_this.foregroundScene.context.measureText(v).width) + 26;

				//当图例超出总宽度时，将先前的图例段作为一个分组布存到 legendList 里，legendList 的每一项都是一个数组，这个数组即是一个图例分组
				if (offsetLeft + width > _this.stage2d.width) {
					_this.legendList.push(Array.from(legendSection));
					legendSection = [];
					offsetLeft = 0;
				}

				//将图例的绘制所需信息存放到一个对象，然后将对象存到图例分组
				legendSection.push({
					name: v,
					shape: _this.shapeList[i],
					width: width,
					height: 24,
					disable: 0,
					pattern: _this.style.colors[i],
					offsetLeft: offsetLeft
				});

				offsetLeft += width;
			});

			//将最后一段图例分组存到 legendList
			if (legendSection.length > 0) this.legendList.push(Array.from(legendSection));
		}

		//图例

	}, {
		key: 'paintLegend',
		value: function paintLegend(context) {
			var _this2 = this;

			if (!this.style.legend) return false;

			//遍历图例分组，this.legendList 实际上是一个二维数组，每一项都是一个分组，每个分组绘制时单独一行
			this.legendList.forEach(function (legendScetion, j) {
				var lastLegend = legendScetion[legendScetion.length - 1];
				var totalWidth = lastLegend.width + lastLegend.offsetLeft;

				context.save();
				context.textAlign = 'left';
				context.lineWidth = 2;
				context.fillStyle = "#000000";

				//(20 + 20 * j) 代表图例在 Y 轴上的偏移, j 每增加 1，图例就会另起一行绘制
				if (_this2.style.legend === 'bottom') {
					context.translate(Math.floor((_this2.stage2d.width - totalWidth + 16) / 2), _this2.legendOffsetTop - 20 * j);
				} else {
					context.translate(Math.floor((_this2.stage2d.width - totalWidth + 16) / 2), _this2.legendOffsetTop + 20 * j);
				}

				legendScetion.forEach(function (legend, i) {
					context.save();
					context.strokeStyle = legend.pattern;
					context.beginPath();
					context.arc(legend.offsetLeft, 0, 5, 0, Math.PI * 2);

					if (context.isPointInPath(_this2.stage2d.mouseX, _this2.stage2d.mouseY)) {
						context.arc(legend.offsetLeft, 0, 6, 0, Math.PI * 2);
						_this2.legendClick(legend);
					}

					context.closePath();

					if (legend.disable) {
						context.fillStyle = "#c9c9c9";
						context.strokeStyle = "#c9c9c9";
					}

					context.fillText(legend.name, legend.offsetLeft + 10, 0);

					context.stroke();
					context.restore();
				});

				context.restore();
			});
		}

		//点击禁用图例

	}, {
		key: 'legendClick',
		value: function legendClick(legend) {
			//检测点击事件
			var clickEventQueue = this.stage2d.clickEventQueue;

			//如果点击事件队列不为空，执行回调，并消耗一次点击坐标
			if (!clickEventQueue.isEmpty()) {
				clickEventQueue.dequeue();
				legend.disable = !legend.disable;
				legend.shape.disable = legend.disable;
				this.setPie();
			}
		}

		//添加 tips

	}, {
		key: 'addTip',
		value: function addTip(format) {
			var _this3 = this;

			_tip2.default.createStyle();
			this.tip = _tip2.default.init(this.stage2d.container);
			this.addEventListener('mousemove', function (e) {
				_this3.tipMove(e, format);
			});
		}
	}, {
		key: 'clearTip',
		value: function clearTip() {
			this.tip.hide();
		}

		//绑定事件

	}, {
		key: 'addEventListener',
		value: function addEventListener(event, callback) {
			this.eventList.push(new _event2.default(event, callback));
		}

		//判断是否为数字

	}, {
		key: 'isNumber',
		value: function isNumber(value) {
			return typeof value === 'number' ? true : false;
		}

		//百分比转数字

	}, {
		key: 'precentToFloat',
		value: function precentToFloat(value) {
			return value.slice(0, -1) / 100;
		}
	}]);

	return Chart;
}();

var ChartPie = exports.ChartPie = function (_Chart) {
	_inherits(ChartPie, _Chart);

	function ChartPie(option) {
		_classCallCheck(this, ChartPie);

		return _possibleConstructorReturn(this, (ChartPie.__proto__ || Object.getPrototypeOf(ChartPie)).call(this, option));
	}

	_createClass(ChartPie, [{
		key: 'initOptions',
		value: function initOptions() {

			var option = this.option;

			var stage2d = this.stage2d;

			//计算半径
			if (typeof option.radius === 'undefined') {
				option.radius = parseInt(Math.min(stage2d.width, stage2d.height) / 2 * 0.8);
			} else {
				if (!this.isNumber(option.radius)) {
					option.radius = parseInt(Math.min(stage2d.width, stage2d.height) / 2 * this.precentToFloat(option.radius));
				}
			}

			//计算饼的圆心坐标
			if (typeof option.center === 'undefined') {
				option.center = [parseInt(stage2d.width / 2), parseInt(stage2d.height / 2)];
			} else {
				if (!this.isNumber(option.center[0])) {
					option.center[0] = parseInt(stage2d.width * this.precentToFloat(option.center[0]));
				}
				if (!this.isNumber(option.center[1])) {
					option.center[1] = parseInt(stage2d.height * this.precentToFloat(option.center[1]));
				}
			}

			//初始化前景画布配置
			var context = this.foregroundScene.context;
			context.strokeStyle = "#ffffff";
			context.lineJoin = "bevel";
			context.miterLimit = 1;
			context.textAlign = "center";
			context.textBaseline = "middle";
			context.font = this.style.font;
			context.fillStyle = "#ffffff";

			//如果没有图例，将值做为图例
			if (typeof option.legend === 'undefined') {
				option.legend = option.data;
			}

			//创建饼图
			this.shapeList = [];

			for (var i in option.data) {

				//创建一个饼形图
				var shape = new _shape.Pie();

				//设置饼形图属性
				shape.stage2d = this.stage2d;
				shape.chart2d = this;
				shape.x = option.center[0];
				shape.y = option.center[1];
				shape.originalX = option.center[0];
				shape.originalY = option.center[1];
				shape.pattern = this.style.colors[i];
				shape.mouseOverPattern = (0, _tool.lighten)(this.style.colors[i]);
				shape.name = option.legend[i];
				shape.value = option.data[i];
				shape.radius = option.radius;
				shape.sAngle = -Math.PI / 2;
				shape.eAngle = -Math.PI / 2;

				this.shapeList.push(shape);
			}

			//图例绘制所需数据
			this.initLegend();

			this.setPie();
		}

		//计算饼形状绘制信息

	}, {
		key: 'setPie',
		value: function setPie(repeat) {
			var _this5 = this;

			//总计
			var total = 0;

			this.shapeList.forEach(function (shape) {
				if (!shape.disable) {
					total += shape.value;
				}
			});

			var sAngle = -Math.PI / 2,
			    eAngle = -Math.PI / 2;

			//计算起始和结束弧度
			this.shapeList.forEach(function (shape) {
				//算出百分比
				if (shape.disable) {
					shape.precent = 0;
				} else {
					shape.precent = shape.value / total * 100;
				}

				eAngle += shape.precent / 50 * Math.PI;

				shape.animate({
					eAngle: eAngle,
					sAngle: sAngle
				});

				sAngle = eAngle;

				//饼上的名称和值显示格式
				if (typeof _this5.style.nameStyle === 'function') {
					shape.nameText = _this5.style.nameStyle(shape.name, shape.value, shape.precent);
				}
				if (typeof _this5.style.nameStyle === 'string') {
					shape.nameText = _this5.style.nameStyle.replace('{a}', shape.name).replace('{b}', shape.value).replace('{c}', Math.round(shape.precent));
				}
				if (typeof _this5.style.valueStyle === 'function') {
					shape.valueText = _this5.style.valueStyle(shape.name, shape.value, shape.precent);
				}
				if (typeof _this5.style.valueStyle === 'string') {
					shape.valueText = _this5.style.valueStyle.replace('{a}', shape.name).replace('{b}', shape.value).replace('{c}', Math.round(shape.precent));
				}
			});

			console.log(this.shapeList);
		}

		//前景绘制（图表）

	}, {
		key: 'foregroundPaint',
		value: function foregroundPaint(scene) {
			var _this6 = this;

			this.foregroundScene.paint(function (context) {

				//遍历并绘制
				_this6.shapeList.forEach(function (shape) {
					shape.paint(context);
				});

				//绘制图例
				_this6.paintLegend(context);
			});
		}

		//背景绘制 （坐标轴，图例等）

	}, {
		key: 'backdropPaint',
		value: function backdropPaint(scene) {
			this.backdropScene.paint(function (context) {});
		}

		//当鼠标 mouseover 时，更新 tip

	}, {
		key: 'tipMove',
		value: function tipMove(e, format) {

			var tipInnerHtml = '<span><i style="background:' + e.color + '"></i>' + format(e.name, e.value, e.precent) + '<span>';
			this.tip.show();
			this.tip.move(e.mouseX, e.mouseY, tipInnerHtml);
		}
	}]);

	return ChartPie;
}(Chart);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.offsetTop = offsetTop;
exports.offsetLeft = offsetLeft;
exports.lighten = lighten;
exports.darken = darken;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//获取元素相对于窗口左边的距离
function offsetTop(elements) {
    var top = elements.offsetTop;
    var parent = elements.offsetParent;
    while (parent != null) {
        top += parent.offsetTop;
        parent = parent.offsetParent;
    }
    return top;
}

//获取元素相对于窗口顶端边的距离
function offsetLeft(elements) {
    var left = elements.offsetLeft;
    var parent = elements.offsetParent;
    while (parent != null) {
        left += parent.offsetLeft;
        parent = parent.offsetParent;
    }
    return left;
}

//防抖和节流

var throttler = function () {
    function throttler() {
        var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        _classCallCheck(this, throttler);

        this.delay = delay;
        this.lastTime = new Date().getTime();
    }

    _createClass(throttler, [{
        key: "throttle",
        value: function throttle(fn) {
            var currentTime = new Date().getTime();
            if (currentTime - this.lastTime > this.delay) {
                console.log(currentTime - this.lastTime, this.delay);
                this.lastTime = currentTime;
                fn();
            }
        }
    }], [{
        key: "delay",
        value: function delay(_delay) {
            return new throttler(_delay);
        }
    }]);

    return throttler;
}();

exports.throttler = throttler;


function rgbToHex(r, g, b) {
    var hex = (r << 16 | g << 8 | b).toString(16);
    return "#" + new Array(Math.abs(hex.length - 7)).join("0") + hex;
}

function hexToRgb(hex) {
    var rgb = [];
    for (var i = 1; i < 7; i += 2) {
        rgb.push(parseInt("0x" + hex.slice(i, i + 2)));
    }
    return rgb;
}

function lighten(hex) {
    var rgb = hexToRgb(hex);
    var arr = rgb.map(function (v) {
        return Math.min(v + 10, 255);
    });
    return rgbToHex(arr[0], arr[1], arr[2]);
}

function darken(hex) {
    var rgb = hexToRgb(hex);
    var arr = rgb.map(function (v) {
        return Math.max(v - 10, 0);
    });
    return rgbToHex(arr[0], arr[1], arr[2]);
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(5);
module.exports = __webpack_require__(0);


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * HiDPI Canvas Polyfill (1.0.10)
 *
 * Author: Jonathan D. Johnson (http://jondavidjohn.com)
 * Homepage: https://github.com/jondavidjohn/hidpi-canvas-polyfill
 * Issue Tracker: https://github.com/jondavidjohn/hidpi-canvas-polyfill/issues
 * License: Apache-2.0
*/
(function (prototype) {

	var pixelRatio = function () {
		var canvas = document.createElement('canvas'),
		    context = canvas.getContext('2d'),
		    backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

		return (window.devicePixelRatio || 1) / backingStore;
	}(),
	    forEach = function forEach(obj, func) {
		for (var p in obj) {
			if (obj.hasOwnProperty(p)) {
				func(obj[p], p);
			}
		}
	},
	    ratioArgs = {
		'fillRect': 'all',
		'clearRect': 'all',
		'strokeRect': 'all',
		'moveTo': 'all',
		'lineTo': 'all',
		'arc': [0, 1, 2],
		'arcTo': 'all',
		'bezierCurveTo': 'all',
		'isPointinPath': 'all',
		'isPointinStroke': 'all',
		'quadraticCurveTo': 'all',
		'rect': 'all',
		'translate': 'all',
		'createRadialGradient': 'all',
		'createLinearGradient': 'all'
	};

	if (pixelRatio === 1) return;

	forEach(ratioArgs, function (value, key) {
		prototype[key] = function (_super) {
			return function () {
				var i,
				    len,
				    args = Array.prototype.slice.call(arguments);

				if (value === 'all') {
					args = args.map(function (a) {
						return a * pixelRatio;
					});
				} else if (Array.isArray(value)) {
					for (i = 0, len = value.length; i < len; i++) {
						args[value[i]] *= pixelRatio;
					}
				}

				return _super.apply(this, args);
			};
		}(prototype[key]);
	});

	// Stroke lineWidth adjustment
	prototype.stroke = function (_super) {
		return function () {
			this.lineWidth *= pixelRatio;
			_super.apply(this, arguments);
			this.lineWidth /= pixelRatio;
		};
	}(prototype.stroke);

	// Text
	//
	prototype.fillText = function (_super) {
		return function () {
			var args = Array.prototype.slice.call(arguments);

			args[1] *= pixelRatio; // x
			args[2] *= pixelRatio; // y

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m * pixelRatio + u;
			});

			_super.apply(this, args);

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m / pixelRatio + u;
			});
		};
	}(prototype.fillText);

	prototype.strokeText = function (_super) {
		return function () {
			var args = Array.prototype.slice.call(arguments);

			args[1] *= pixelRatio; // x
			args[2] *= pixelRatio; // y

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m * pixelRatio + u;
			});

			_super.apply(this, args);

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m / pixelRatio + u;
			});
		};
	}(prototype.strokeText);
	window.pixelRatio = pixelRatio;
})(CanvasRenderingContext2D.prototype);
;(function (prototype) {
	prototype.getContext = function (_super) {
		return function (type) {
			var backingStore,
			    ratio,
			    context = _super.call(this, type);

			if (type === '2d') {

				backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

				ratio = (window.devicePixelRatio || 1) / backingStore;

				if (ratio > 1) {
					this.style.height = this.height + 'px';
					this.style.width = this.width + 'px';
					this.width *= ratio;
					this.height *= ratio;
				}
			}

			return context;
		};
	}(prototype.getContext);
})(HTMLCanvasElement.prototype);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //引入渲染优化方法


//引入场景对象


//引入图表对象


//队列


//引入常量名


//引入工具函数


var _render = __webpack_require__(1);

var _render2 = _interopRequireDefault(_render);

var _scene = __webpack_require__(7);

var _scene2 = _interopRequireDefault(_scene);

var _chart = __webpack_require__(2);

var _chart2 = _interopRequireDefault(_chart);

var _queue = __webpack_require__(11);

var _queue2 = _interopRequireDefault(_queue);

var _constants = __webpack_require__(12);

var _tool = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//iDOMHighResTimeStamp
var lastIDOMHighResTimeStamp = 0;

//创建坐标点，用于记录一次鼠标指向
function point(x, y) {
    return { x: x, y: y };
}

//舞台

var Stage = function () {
    function Stage(container) {
        _classCallCheck(this, Stage);

        //容器, canvas 元素的 parent
        this.container = container;

        this.container.style.position = 'relative';

        //图表容器
        this.chartList = [];

        //舞台的宽和高，既是容器的宽和高，实际也是canvas的宽和高
        this.width = container.clientWidth;
        this.height = container.clientHeight;

        //获取舞台相对于当前视窗的偏移，实际上也是canvas相对于当前视窗的偏移
        this.offset = {
            top: (0, _tool.offsetTop)(container),
            left: (0, _tool.offsetLeft)(container)

            //侦听器容器
        };this.eventlist = [];

        //当前舞台的缩放
        this.scale = 1;

        //当前舞台的偏移
        this.translateX = 0;
        this.translateY = 0;

        //设备像素比
        this.pixelRatio = pixelRatio;

        //鼠标X
        this.mouseX = 0;

        //鼠标Y
        this.mouseY = 0;

        //鼠标相对于页面X
        this.pageX = 0;

        //鼠标相对于页面Y
        this.pageY = 0;

        //当前帧距离上一帧的时间间隔
        this.interval = 0;

        this.clickEventQueue = new _queue2.default();
        this.mouseupEventQueue = new _queue2.default();
        this.mousedownEventQueue = new _queue2.default();
        this.mousemoveEventQueue = new _queue2.default();

        this.initEventListener();
    }

    //初始化事件监听


    _createClass(Stage, [{
        key: 'initEventListener',
        value: function initEventListener() {
            var _this = this;

            //添加事件监听
            document.addEventListener("mouseup", function (e) {}, false);

            this.container.addEventListener("mousedown", function (e) {
                //coreStage2d.stageMouseDown(e)
            }, false);

            this.container.addEventListener("click", function (e) {
                _this.clickEventQueue.enqueue(point(_this.mouseX, _this.mouseY));
            }, false);

            this.container.addEventListener("mousemove", function (e) {
                _this.pageX = e.pageX;
                _this.pageY = e.pageY;
                _this.mouseX = (e.pageX - _this.offset.left) * _this.pixelRatio;
                _this.mouseY = (e.pageY - _this.offset.top) * _this.pixelRatio;

                _this.mousemoveEventQueue.enqueue(point(_this.mouseX, _this.mouseY));
            }, false);

            //缩放事件
            this.container.addEventListener("DOMMouseScroll", function (e) {
                //缩放，暂时禁用
                //this.stageScroll(e)
            }, false);
            //兼容FF
            this.container.onmousewheel = function (e) {
                //缩放，暂时禁用
                //this.stageScroll(e)
            };
        }

        //创建一个场景

    }, {
        key: 'createScene',
        value: function createScene(type) {
            //初始化一个场景，并绑定当前舞台
            var scener = _scene2.default.init(this);
            return scener;
        }

        //添加一个图表

    }, {
        key: 'addChart',
        value: function addChart(chart) {
            chart.init(this);
            this.chartList.push(chart);
        }
    }, {
        key: 'stageScroll',
        value: function stageScroll(e) {

            //判定鼠标指针在画布内
            if (Math.abs(e.pageX) > this.offset.left && Math.abs(e.pageX) < this.offset.left + this.width && Math.abs(e.pageY) > this.offset.top && Math.abs(e.pageY) < this.offset.top + this.height) {
                //阻止冒泡
                e.stopPropagation();

                //计算出缩放前的鼠标在场景中的 X、Y
                var beforeX = (e.pageX - this.offset.left - this.translateX) / this.scale,
                    beforeY = (e.pageY - this.offset.top - this.translateY) / this.scale;

                if (e.detail > 0 || e.wheelDelta < 0) {
                    if (this.scale > 0.2) this.scale -= .1;
                } else {
                    if (this.scale < 4) this.scale += .1;
                }

                this.translateX = -beforeX * this.scale + (e.pageX - this.offset.left);
                this.translateY = -beforeY * this.scale + (e.pageY - this.offset.top);
            }

            console.log(this.scale);
        }

        //背景绘制

    }, {
        key: 'backdropPaint',
        value: function backdropPaint() {
            this.chartList.forEach(function (chart) {
                chart.backdropPaint();
            });
        }

        //前景绘制

    }, {
        key: 'foregroundPaint',
        value: function foregroundPaint() {
            var _this2 = this;

            this.chartList.forEach(function (chart) {
                chart.foregroundPaint();
            });

            //此处计算 this.interval


            //释放鼠标点击坐标点
            if (!this.clickEventQueue.isEmpty()) this.clickEventQueue.dequeue();

            //释放鼠标移动坐标点
            if (!this.mousemoveEventQueue.isEmpty()) {
                this.mousemoveEventQueue.dequeue();
                this.chartList.forEach(function (chart) {
                    //鼠标移到 chart 图外，清除 tip
                    chart.clearTip();
                });
            }

            //DOMHighResTimeStamp 是一个double类型，用于存储时间值。该值可以是离散的时间点或两个离散时间点之间的时间差，单位为毫秒
            (0, _render2.default)(function (iDOMHighResTimeStamp) {
                //计算每次绘制的时间间隔
                _this2.interval = iDOMHighResTimeStamp - lastIDOMHighResTimeStamp;
                lastIDOMHighResTimeStamp = iDOMHighResTimeStamp;
                _this2.foregroundPaint();
            });
        }

        //开始绘制

    }, {
        key: 'startPaint',
        value: function startPaint() {
            var _this3 = this;

            (0, _render2.default)(function (iDOMHighResTimeStamp) {

                //计算每次绘制的时间间隔
                _this3.interval = iDOMHighResTimeStamp - lastIDOMHighResTimeStamp;
                lastIDOMHighResTimeStamp = iDOMHighResTimeStamp;

                //背景只绘制一次
                _this3.backdropPaint();

                //前景一般需要重复绘制
                _this3.foregroundPaint();
            });
        }
    }]);

    return Stage;
}();

exports.default = Stage;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//场景
var Scene = function () {
    function Scene(stage2d, canvas) {
        _classCallCheck(this, Scene);

        //场景对应的舞台
        this.stage2d = stage2d;

        this.width = stage2d.width;

        this.height = stage2d.height;

        //场景画布对象
        this.canvas = canvas;

        //绘图对象
        this.context = canvas.getContext('2d');
    }

    _createClass(Scene, [{
        key: 'paint',
        value: function paint(callback) {
            //清理画面
            this.context.clearRect(0, 0, this.width, this.height);

            //重置画布的透明度
            this.context.globalAlpha = 1;

            this.context.save();

            //重新设定画布偏移和缩放
            this.context.translate(this.stage2d.translateX, this.stage2d.translateY);

            // console.log("this.scale", this.scale);
            this.context.scale(this.stage2d.scale, this.stage2d.scale);

            //需要重复绘制的内容
            callback(this.context);

            this.context.restore();
        }
    }], [{
        key: 'init',
        value: function init(stage2d, index) {

            //创建 Canvas，并添加到场景
            var canvas = document.createElement('canvas');
            canvas.width = stage2d.width;
            canvas.height = stage2d.height;
            canvas.style.position = 'absolute';

            stage2d.container.appendChild(canvas);

            return new Scene(stage2d, canvas);
        }
    }]);

    return Scene;
}();

exports.default = Scene;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//事件对象
var Event2d = function Event2d(event, callback) {
    _classCallCheck(this, Event2d);

    //事件类型
    this.eventType = event;

    //事件回调
    this.callback = callback;
};

exports.default = Event2d;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//场景
var Tip = function () {
    function Tip(element) {
        _classCallCheck(this, Tip);

        this.element = element;
    }

    _createClass(Tip, [{
        key: 'move',
        value: function move(x, y, html) {
            this.element.style.left = x + 20 + 'px';
            this.element.style.top = y + 20 + 'px';
            this.element.innerHTML = html;
        }
    }, {
        key: 'hide',
        value: function hide(x, y, html) {
            this.element.style.display = 'none';
        }
    }, {
        key: 'show',
        value: function show(x, y, html) {
            this.element.style.display = 'block';
        }
    }], [{
        key: 'init',
        value: function init(container) {

            //创建 Canvas，并添加到场景
            var box = document.createElement('div');
            box.classList.add('minichart-tip');
            container.appendChild(box);

            return new Tip(box);
        }
    }, {
        key: 'createStyle',
        value: function createStyle() {
            console.log('style');
            var style = document.createElement('style');
            style.type = 'text/css';
            style.innerHTML = '\n            .minichart-tip {\n                position: absolute;\n                display: \'none\';\n                min-width: 60px;\n                min-height: 24px;\n                padding: 6px 10px;\n                border-radius: 4px;\n                background-color: rgba(255,255,255,.8);\n                box-shadow: 0 0 30px rgba(0,0,0,.5);\n                transition: left 0.2s ease, width 0.2s ease, top 0.2s ease, height 0.2s ease;\n            }\n            .minichart-tip span {\n                display: block;\n                vertical-align: middle;\n                line-height: 24px;\n                color: #333;\n                font-size: 12px;\n            }\n            .minichart-tip i {\n                display: inline-block;\n                vertical-align: middle;\n                width: 7px;\n                height: 7px;\n                border-radius: 50%;\n                background-color: #ccc;\n                margin-right: 6px;\n            }\n        ';
            document.getElementsByTagName('head').item(0).appendChild(style);
        }
    }]);

    return Tip;
}();

exports.default = Tip;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Pie = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _render = __webpack_require__(1);

var _render2 = _interopRequireDefault(_render);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//图形基类
var Shape = function () {
    function Shape() {
        _classCallCheck(this, Shape);

        this.recoverAnimateIng = false;
    }

    //过渡动画


    _createClass(Shape, [{
        key: 'animate',
        value: function animate(option) {
            var _this = this;

            var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;


            //属性原始值
            var originalValues = {};

            //属性变化量
            var changeValues = {};

            for (var key in option) {
                if (key === 'eAngle') {
                    originalValues[key] = this[key] * 100;
                    changeValues[key] = option[key] * 100 - originalValues[key];
                } else {
                    originalValues[key] = this[key];
                    changeValues[key] = option[key] - this[key];
                }
            }

            var time = 0;

            var durationTime = speed / 1000;

            var step = function step() {

                time = time + _this.stage2d.interval;

                if (time > speed) {
                    time = speed;
                }

                for (var _key in changeValues) {

                    if (_key === 'eAngle') {
                        //通过缓动函数求出某一属性在时间轴上对应的过度值
                        _this[_key] = _this.easeOut(time / 1000, originalValues[_key], changeValues[_key], durationTime) / 100;
                    } else {
                        //通过缓动函数求出某一属性在时间轴上对应的过度值
                        _this[_key] = _this.easeOut(time / 1000, originalValues[_key], changeValues[_key], durationTime);
                    }

                    // console.table([
                    //     {
                    //         time,
                    //         originalValue: originalValues[key],
                    //         changeValue: changeValues[key],
                    //         speed,
                    //         value: this[key],
                    //         eAngel: option[key] * 100
                    //     }
                    // ])
                }

                if (time < speed) {
                    (0, _render2.default)(step);
                }
            };

            (0, _render2.default)(step);
        }

        /*!
         * [easeOut 缓动函数]
         * @param  {[float]} t:timestamp [动画执行到当前帧所经过的时间] 如：0.3s
         * @param  {[float]} b:begining [起始值] 如：10
         * @param  {[float]} c:change [需要变化的量] 如：从 10 到 100，变化量是 90
         * @param  {[float]} d:duration [动画从开始到结束的总时长] 如：0.4s
         * @return {[float]}   [description] 时间轴上对应的过度值
         */

    }, {
        key: 'easeOut',
        value: function easeOut(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        }
    }]);

    return Shape;
}();

/*
    Math.sin(x)    x 的正玄值。返回值在 -1.0 到 1.0 之间；
    Math.cos(x)    x 的余弦值。返回的是 -1.0 到 1.0 之间的数；
    这两个函数中的X 都是指的“弧度”而非“角度” 　　
    弧度的计算公式为： 角度*（PI/180）；　　（角度转弧度可参考：角度与弧度互转）
    30° 角度 的弧度 = 30 * （PI/180）
 */

//饼状图


var Pie = exports.Pie = function (_Shape) {
    _inherits(Pie, _Shape);

    function Pie() {
        _classCallCheck(this, Pie);

        //类型
        var _this2 = _possibleConstructorReturn(this, (Pie.__proto__ || Object.getPrototypeOf(Pie)).call(this));

        _this2.type = 'pie';

        //形状的初始X坐标
        _this2.originalX = 0;

        //形状的初始Y坐标
        _this2.originalY = 0;

        //形状的X坐标
        _this2.x = 0;

        //形状的Y坐标
        _this2.y = 0;

        //填充颜色或图案
        _this2.pattern = '#ffffff';

        //填充颜色或图案 mouseover
        _this2.mouseOverPattern = '#ffffff';

        //名称
        _this2.name = '';

        //值
        _this2.value = 0;

        //半径
        _this2.radius = 0;

        //百分比
        _this2.precent = 0;

        //起始角，以弧度计
        _this2.sAngle = 0;

        //结束角，以弧度计
        _this2.eAngle = 0;

        //名称信息, 决定是否在饼外显示名称
        _this2.nameText = null;

        //值信息, 决定是否在饼上显示值或百分比
        _this2.valueText = null;

        //临时禁用
        _this2.disable = 0;

        return _this2;
    }

    //绘制饼形


    _createClass(Pie, [{
        key: 'paintPie',
        value: function paintPie(context) {

            context.beginPath();

            //对于饼状图，xy是圆的中心
            context.moveTo(this.x, this.y);

            context.arc(this.x, this.y, this.radius, this.sAngle, this.eAngle);

            context.closePath();

            if (context.isPointInPath(this.stage2d.mouseX, this.stage2d.mouseY)) {
                context.fillStyle = this.mouseOverPattern;
                this.eventDetection();
            } else {
                context.fillStyle = this.pattern;
            }

            context.stroke();
            context.fill();
        }

        //鼠标事件检测

    }, {
        key: 'eventDetection',
        value: function eventDetection() {

            var eventList = this.chart2d.eventList;

            if (eventList.length > 0) {
                //遍历事件列表，以响应多个事件
                for (var i in eventList) {
                    switch (eventList[i].eventType) {
                        case 'click':
                            //检测点击事件
                            var clickEventQueue = this.stage2d.clickEventQueue;

                            //如果点击事件队列不为空，执行回调，并消耗一次点击坐标
                            if (!clickEventQueue.isEmpty()) {
                                eventList[i].callback(this.getEventData(clickEventQueue.dequeue()));
                                //先复原，然后播放点击动画,
                                this.chart2d.recoverAnimate();
                                if (this.recoverAnimateIng) {
                                    this.recoverAnimateIng = false;
                                } else {
                                    this.clickAnimate();
                                }
                            }

                            break;

                        case 'mousemove':
                            //检测点击事件
                            var mousemoveEventQueue = this.stage2d.mousemoveEventQueue;

                            //如果点击事件队列不为空，执行回调，并消耗一次点击坐标
                            if (!mousemoveEventQueue.isEmpty()) {
                                eventList[i].callback(this.getEventData(mousemoveEventQueue.dequeue()));
                            }

                            break;
                        default:

                    }
                }
            }
        }
    }, {
        key: 'getEventData',
        value: function getEventData(point) {
            return {
                mouseX: parseInt(this.stage2d.mouseX / this.stage2d.pixelRatio),
                mouseY: parseInt(this.stage2d.mouseY / this.stage2d.pixelRatio),
                pageX: this.stage2d.pageX,
                pageY: this.stage2d.pageY,
                color: this.pattern,
                name: this.name,
                value: this.value,
                precent: this.precent
            };
        }

        //点击动画

    }, {
        key: 'clickAnimate',
        value: function clickAnimate() {

            //计算饼形中线弧度
            var radian = (this.eAngle - this.sAngle) / 2 + this.sAngle + 0.5 * Math.PI;

            //计算移动后的圆心坐标
            var x = this.x + Math.sin(radian) * 10;
            var y = this.y - Math.cos(radian) * 10;

            //先记录当前 shape 和圆心坐标，复原时用
            this.chart2d.addRecoverAnimate(this, {
                x: this.x,
                y: this.y
            });

            //开始播放移动动画
            this.animate({
                x: x,
                y: y
            });

            this.recoverAnimateIng = true;
        }
    }, {
        key: 'paint',
        value: function paint(context) {

            //保存画布句柄，开始绘制饼形
            context.save();
            this.paintPie(context);
            context.restore();

            //计算饼形中线弧度
            var radian = (this.eAngle - this.sAngle) / 2 + this.sAngle + 0.5 * Math.PI;

            if (this.chart2d.style.valueStyle && !this.disable) {
                //绘制数据值
                var x = this.x + Math.sin(radian) * (this.radius * .7);
                var y = this.y - Math.cos(radian) * (this.radius * .7);
                context.fillText(this.valueText, x, y);
            }

            if (this.chart2d.style.nameStyle && !this.disable) {
                //开始绘制名称，计算名称指引线开始坐标(sx, xy)和结束(ex, ey)坐标
                var sx = this.originalX + Math.sin(radian) * (this.radius + 4);
                var sy = this.originalY - Math.cos(radian) * (this.radius + 4);
                var ex = this.originalX + Math.sin(radian) * (this.radius + 20);
                var ey = this.originalY - Math.cos(radian) * (this.radius + 20);

                //保存画布句柄，开始画线
                context.save();

                context.strokeStyle = this.pattern;
                context.beginPath();
                context.moveTo(sx, sy);
                context.lineTo(ex, ey);
                context.stroke();

                //绘制名称
                context.fillStyle = this.pattern;
                if (radian < Math.PI) {
                    context.textAlign = "left";
                    context.fillText(this.nameText, ex + 3, ey);
                } else {
                    context.textAlign = "right";
                    context.fillText(this.nameText, ex - 3, ey);
                }
                context.restore();
            }
        }
    }]);

    return Pie;
}(Shape);

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Queue = function () {
    function Queue(stage2d, canvas) {
        _classCallCheck(this, Queue);

        this.items = [];
    }

    //向队列尾部添加一个新的项


    _createClass(Queue, [{
        key: "enqueue",
        value: function enqueue(element) {
            this.items.push(element);
        }

        //从队列中取出一个元素，并返回该元素

    }, {
        key: "dequeue",
        value: function dequeue() {
            return this.items.shift();
        }

        //查看队列最前面的元素

    }, {
        key: "front",
        value: function front() {
            return this.items[0];
        }

        //查看队列是否为空，如果为空，返回true；否则返回false

    }, {
        key: "isEmpty",
        value: function isEmpty() {
            return this.items.length == 0;
        }

        //查看队列的长度

    }, {
        key: "size",
        value: function size() {
            return this.items.length;
        }
    }]);

    return Queue;
}();

exports.default = Queue;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//鼠标按下事件
var EVENT_MOUSE_DOWN = exports.EVENT_MOUSE_DOWN = "EVENT_MOUSE_DOWN";

//鼠标移动事件
var EVENT_MOUSE_MOVE = exports.EVENT_MOUSE_MOVE = "EVENT_MOUSE_MOVE";

//鼠标松开事件
var EVENT_MOUSE_UP = exports.EVENT_MOUSE_UP = "EVENT_MOUSE_UP";

//鼠标松开事件
var EVENT_MOUSE_SCROLL = exports.EVENT_MOUSE_SCROLL = "EVENT_MOUSE_SCROLL";

/***/ })
/******/ ]);