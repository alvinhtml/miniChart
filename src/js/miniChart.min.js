/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/ 		if(executeModules) {
/******/ 			for(i=0; i < executeModules.length; i++) {
/******/ 				result = __webpack_require__(__webpack_require__.s = executeModules[i]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		1: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _stage = __webpack_require__(6);

var _stage2 = _interopRequireDefault(_stage);

var _chart = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var miniChart = function () {
    function miniChart(container) {
        _classCallCheck(this, miniChart);

        //版本
        this.version = '1.0';

        this.container = container;

        this.chartList = [];
    }

    _createClass(miniChart, [{
        key: 'setOption',
        value: function setOption(option) {

            var stage2d = new _stage2.default(this.container);

            //创建一个饼状图图表，传入配置信息
            var chartPie2d = new _chart.ChartPie(option);

            this.chartList.push(chartPie2d);

            stage2d.addChart(chartPie2d);

            stage2d.startPaint();
        }

        //绑定事件

    }, {
        key: 'addEventListener',
        value: function addEventListener(event, callback) {
            this.chartList.forEach(function (chart) {
                chart.addEventListener(event, callback);
            });
        }

        /*!
         * [init 初始化图表]
         * @return {[Object]} [图表句柄]
         */
        /*!
         * [init description]
         * @param  {[type]} element [description]
         * @return {[type]}         [description]
         */

    }], [{
        key: 'init',
        value: function init(container) {
            return new miniChart(container);
        }
    }]);

    return miniChart;
}();

exports.default = miniChart;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
//渲染
var Render = function () {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
        window.setTimeout(callback, 1000 / 60);
    };
}();

exports.default = Render;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ChartPie = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //引入工具函数


//引入事件对象


//引入工具函数


var _tool = __webpack_require__(3);

var _event = __webpack_require__(8);

var _event2 = _interopRequireDefault(_event);

var _shape = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//图表默认配置信息

var colors = ['#fa5a64', '#1bbc9b', '#f48804', '#eb41a0', '#f1c40f', '#c3d72d', '#32c5d2', '#50d2fa', '#c87846', '#6e37e6', '#8c50c8'];

// NOTE: chart 对象类似导演，通过舞台布置场景


var Chart = function () {
	function Chart(option) {
		_classCallCheck(this, Chart);

		//图表配置数据
		this.option = option;

		this.stage2d = null;

		this.type = option.type;

		//图例
		this.legend = '';

		//图形列表
		this.shapeList = [];

		//事件列表
		this.eventList = [];

		//需要复原的动画
		this.recoverAnimateList = [];
	}

	_createClass(Chart, [{
		key: 'init',
		value: function init(stage2d) {
			//将图表绑定到场景实例
			this.stage2d = stage2d;

			//创建一个背景场景对象，用于绘制坐标轴，图例等只需绘制一次的内容
			this.backdropScene = stage2d.createScene("backdrop");

			//创建一个前景场景对象，用于绘制饼图
			this.foregroundScene = stage2d.createScene("foreground");

			this.setPie();
		}

		//添加一个等待复原的动画

	}, {
		key: 'addRecoverAnimate',
		value: function addRecoverAnimate(shape, option) {
			this.recoverAnimateList.push({
				shape: shape,
				option: option
			});
		}

		//复原的动画

	}, {
		key: 'recoverAnimate',
		value: function recoverAnimate(shape, option) {
			this.recoverAnimateList.forEach(function (v) {
				v.shape.animate(v.option);
			});
		}

		//绑定事件

	}, {
		key: 'addEventListener',
		value: function addEventListener(event, callback) {
			this.eventList.push(new _event2.default(event, callback));
		}
	}]);

	return Chart;
}();

var ChartPie = exports.ChartPie = function (_Chart) {
	_inherits(ChartPie, _Chart);

	function ChartPie(option) {
		_classCallCheck(this, ChartPie);

		return _possibleConstructorReturn(this, (ChartPie.__proto__ || Object.getPrototypeOf(ChartPie)).call(this, option));
	}

	_createClass(ChartPie, [{
		key: 'setPie',
		value: function setPie() {
			var _this2 = this;

			var option = this.option;

			var stage2d = this.stage2d;

			//计算半径
			var radius = Math.min(stage2d.width, stage2d.height) / 2 * parseInt(option.radius.slice(0, -1)) / 100;

			//计算饼的圆心坐标
			var centerX = stage2d.width * parseInt(option.center[0].slice(0, -1)) / 100;
			var centerY = stage2d.height * parseInt(option.center[1].slice(0, -1)) / 100;

			//计算饼图百分比
			if (Array.isArray(option.data) && option.data.length > 0) {

				var list = option.data;

				//总计
				var total = 0;

				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var v = _step.value;

						total += v.value;
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				var sAngle = -Math.PI / 2,
				    eAngle = -Math.PI / 2;

				var shapeList = list.map(function (v, i) {

					//创建一个饼形图
					var shape = new _shape.Pie();

					//设置饼形图属性
					shape.stage2d = _this2.stage2d;
					shape.chart2d = _this2;
					shape.x = centerX;
					shape.y = centerY;
					shape.originalX = centerX;
					shape.originalY = centerY;
					shape.pattern = colors[i];
					shape.mouseOverPattern = (0, _tool.lighten)(colors[i]);
					shape.name = v.name;
					shape.value = v.value;
					shape.radius = radius;
					shape.precent = Math.round(v.value / total * 100);

					eAngle += shape.precent / 50 * Math.PI;

					shape.sAngle = sAngle;
					shape.eAngle = sAngle;

					sAngle = eAngle;

					//执行一个动画
					shape.animate({
						eAngle: eAngle
					});

					return shape;
				});

				this.shapeList = shapeList;
			}
		}

		//前景绘制（图表）

	}, {
		key: 'foregroundPaint',
		value: function foregroundPaint(scene) {
			var _this3 = this;

			this.foregroundScene.paint(function (context) {

				//设置绘制时 canvas 默认属性
				context.strokeStyle = "#ffffff";
				context.lineJoin = "bevel";
				context.miterLimit = 1;
				context.textAlign = "center";
				context.textBaseline = "middle";
				context.font = "12px sans-serif";
				context.fillStyle = "#ffffff";

				//遍历并绘制
				_this3.shapeList.forEach(function (shape) {
					shape.paint(context);
				});
			});
		}

		//背景绘制 （坐标轴，图例等）

	}, {
		key: 'backdropPaint',
		value: function backdropPaint(scene) {}
	}]);

	return ChartPie;
}(Chart);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.offsetTop = offsetTop;
exports.offsetLeft = offsetLeft;
exports.lighten = lighten;
exports.darken = darken;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//获取元素相对于窗口左边的距离
function offsetTop(elements) {
    var top = elements.offsetTop;
    var parent = elements.offsetParent;
    while (parent != null) {
        top += parent.offsetTop;
        parent = parent.offsetParent;
    }
    return top;
}

//获取元素相对于窗口顶端边的距离
function offsetLeft(elements) {
    var left = elements.offsetLeft;
    var parent = elements.offsetParent;
    while (parent != null) {
        left += parent.offsetLeft;
        parent = parent.offsetParent;
    }
    return left;
}

//防抖和节流

var throttler = function () {
    function throttler() {
        var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        _classCallCheck(this, throttler);

        this.delay = delay;
        this.lastTime = new Date().getTime();
    }

    _createClass(throttler, [{
        key: "throttle",
        value: function throttle(fn) {
            var currentTime = new Date().getTime();
            if (currentTime - this.lastTime > this.delay) {
                console.log(currentTime - this.lastTime, this.delay);
                this.lastTime = currentTime;
                fn();
            }
        }
    }], [{
        key: "delay",
        value: function delay(_delay) {
            return new throttler(_delay);
        }
    }]);

    return throttler;
}();

exports.throttler = throttler;


function rgbToHex(r, g, b) {
    var hex = (r << 16 | g << 8 | b).toString(16);
    return "#" + new Array(Math.abs(hex.length - 7)).join("0") + hex;
}

function hexToRgb(hex) {
    var rgb = [];
    for (var i = 1; i < 7; i += 2) {
        rgb.push(parseInt("0x" + hex.slice(i, i + 2)));
    }
    return rgb;
}

function lighten(hex) {
    var rgb = hexToRgb(hex);
    var arr = rgb.map(function (v) {
        return Math.min(v + 10, 255);
    });
    return rgbToHex(arr[0], arr[1], arr[2]);
}

function darken(hex) {
    var rgb = hexToRgb(hex);
    var arr = rgb.map(function (v) {
        return Math.max(v - 10, 0);
    });
    return rgbToHex(arr[0], arr[1], arr[2]);
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(5);
module.exports = __webpack_require__(0);


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * HiDPI Canvas Polyfill (1.0.10)
 *
 * Author: Jonathan D. Johnson (http://jondavidjohn.com)
 * Homepage: https://github.com/jondavidjohn/hidpi-canvas-polyfill
 * Issue Tracker: https://github.com/jondavidjohn/hidpi-canvas-polyfill/issues
 * License: Apache-2.0
*/
(function (prototype) {

	var pixelRatio = function () {
		var canvas = document.createElement('canvas'),
		    context = canvas.getContext('2d'),
		    backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

		return (window.devicePixelRatio || 1) / backingStore;
	}(),
	    forEach = function forEach(obj, func) {
		for (var p in obj) {
			if (obj.hasOwnProperty(p)) {
				func(obj[p], p);
			}
		}
	},
	    ratioArgs = {
		'fillRect': 'all',
		'clearRect': 'all',
		'strokeRect': 'all',
		'moveTo': 'all',
		'lineTo': 'all',
		'arc': [0, 1, 2],
		'arcTo': 'all',
		'bezierCurveTo': 'all',
		'isPointinPath': 'all',
		'isPointinStroke': 'all',
		'quadraticCurveTo': 'all',
		'rect': 'all',
		'translate': 'all',
		'createRadialGradient': 'all',
		'createLinearGradient': 'all'
	};

	if (pixelRatio === 1) return;

	forEach(ratioArgs, function (value, key) {
		prototype[key] = function (_super) {
			return function () {
				var i,
				    len,
				    args = Array.prototype.slice.call(arguments);

				if (value === 'all') {
					args = args.map(function (a) {
						return a * pixelRatio;
					});
				} else if (Array.isArray(value)) {
					for (i = 0, len = value.length; i < len; i++) {
						args[value[i]] *= pixelRatio;
					}
				}

				return _super.apply(this, args);
			};
		}(prototype[key]);
	});

	// Stroke lineWidth adjustment
	prototype.stroke = function (_super) {
		return function () {
			this.lineWidth *= pixelRatio;
			_super.apply(this, arguments);
			this.lineWidth /= pixelRatio;
		};
	}(prototype.stroke);

	// Text
	//
	prototype.fillText = function (_super) {
		return function () {
			var args = Array.prototype.slice.call(arguments);

			args[1] *= pixelRatio; // x
			args[2] *= pixelRatio; // y

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m * pixelRatio + u;
			});

			_super.apply(this, args);

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m / pixelRatio + u;
			});
		};
	}(prototype.fillText);

	prototype.strokeText = function (_super) {
		return function () {
			var args = Array.prototype.slice.call(arguments);

			args[1] *= pixelRatio; // x
			args[2] *= pixelRatio; // y

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m * pixelRatio + u;
			});

			_super.apply(this, args);

			this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
				return m / pixelRatio + u;
			});
		};
	}(prototype.strokeText);
	window.pixelRatio = pixelRatio;
})(CanvasRenderingContext2D.prototype);
;(function (prototype) {
	prototype.getContext = function (_super) {
		return function (type) {
			var backingStore,
			    ratio,
			    context = _super.call(this, type);

			if (type === '2d') {

				backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

				ratio = (window.devicePixelRatio || 1) / backingStore;

				if (ratio > 1) {
					this.style.height = this.height + 'px';
					this.style.width = this.width + 'px';
					this.width *= ratio;
					this.height *= ratio;
				}
			}

			return context;
		};
	}(prototype.getContext);
})(HTMLCanvasElement.prototype);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //引入渲染优化方法


//引入场景对象


//引入图表对象


//队列


//引入常量名


//引入工具函数


var _render = __webpack_require__(1);

var _render2 = _interopRequireDefault(_render);

var _scene = __webpack_require__(7);

var _scene2 = _interopRequireDefault(_scene);

var _chart = __webpack_require__(2);

var _chart2 = _interopRequireDefault(_chart);

var _queue = __webpack_require__(10);

var _queue2 = _interopRequireDefault(_queue);

var _constants = __webpack_require__(11);

var _tool = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//iDOMHighResTimeStamp
var lastIDOMHighResTimeStamp = 0;

//创建坐标点，用于记录一次鼠标指向
function point(x, y) {
    return { x: x, y: y };
}

//舞台

var Stage = function () {
    function Stage(container) {
        _classCallCheck(this, Stage);

        //容器, canvas 元素的 parent
        this.container = container;

        this.container.style.position = 'relative';

        //图表容器
        this.chartList = [];

        //舞台的宽和高，既是容器的宽和高，实际也是canvas的宽和高
        this.width = container.clientWidth;
        this.height = container.clientHeight;

        //获取舞台相对于当前视窗的偏移，实际上也是canvas相对于当前视窗的偏移
        this.offset = {
            top: (0, _tool.offsetTop)(container),
            left: (0, _tool.offsetLeft)(container)

            //侦听器容器
        };this.eventlist = [];

        //当前舞台的缩放
        this.scale = 1;

        //当前舞台的偏移
        this.translateX = 0;
        this.translateY = 0;

        //设备像素比
        this.pixelRatio = pixelRatio;

        //鼠标X
        this.mouseX = 0;

        //鼠标Y
        this.mouseY = 0;

        //鼠标相对于页面X
        this.pageX = 0;

        //鼠标相对于页面Y
        this.pageY = 0;

        //当前帧距离上一帧的时间间隔
        this.interval = 0;

        this.clickEventQueue = new _queue2.default();
        this.mouseupEventQueue = new _queue2.default();
        this.mousedownEventQueue = new _queue2.default();
        this.mousemoveEventQueue = new _queue2.default();

        this.initEventListener();
    }

    //初始化事件监听


    _createClass(Stage, [{
        key: 'initEventListener',
        value: function initEventListener() {
            var _this = this;

            //添加事件监听
            document.addEventListener("mouseup", function (e) {}, false);

            this.container.addEventListener("mousedown", function (e) {
                //coreStage2d.stageMouseDown(e)
            }, false);

            this.container.addEventListener("click", function (e) {
                _this.clickEventQueue.enqueue(point(_this.mouseX, _this.mouseY));
            }, false);

            this.container.addEventListener("mousemove", function (e) {
                _this.pageX = e.pageX;
                _this.pageY = e.pageY;
                _this.mouseX = (e.pageX - _this.offset.left) * _this.pixelRatio;
                _this.mouseY = (e.pageY - _this.offset.top) * _this.pixelRatio;

                _this.mousemoveEventQueue.enqueue(point(_this.mouseX, _this.mouseY));
            }, false);

            //缩放事件
            this.container.addEventListener("DOMMouseScroll", function (e) {
                //缩放，暂时禁用
                //this.stageScroll(e)
            }, false);
            //兼容FF
            this.container.onmousewheel = function (e) {
                //缩放，暂时禁用
                //this.stageScroll(e)
            };
        }

        //创建一个场景

    }, {
        key: 'createScene',
        value: function createScene(type) {
            //初始化一个场景，并绑定当前舞台
            var scener = _scene2.default.init(this);

            return scener;
        }

        //添加一个图表

    }, {
        key: 'addChart',
        value: function addChart(chart) {
            chart.init(this);
            this.chartList.push(chart);
        }
    }, {
        key: 'stageScroll',
        value: function stageScroll(e) {

            //判定鼠标指针在画布内
            if (Math.abs(e.pageX) > this.offset.left && Math.abs(e.pageX) < this.offset.left + this.width && Math.abs(e.pageY) > this.offset.top && Math.abs(e.pageY) < this.offset.top + this.height) {
                //阻止冒泡
                e.stopPropagation();

                //计算出缩放前的鼠标在场景中的 X、Y
                var beforeX = (e.pageX - this.offset.left - this.translateX) / this.scale,
                    beforeY = (e.pageY - this.offset.top - this.translateY) / this.scale;

                if (e.detail > 0 || e.wheelDelta < 0) {
                    if (this.scale > 0.2) this.scale -= .1;
                } else {
                    if (this.scale < 4) this.scale += .1;
                }

                this.translateX = -beforeX * this.scale + (e.pageX - this.offset.left);
                this.translateY = -beforeY * this.scale + (e.pageY - this.offset.top);
            }

            console.log(this.scale);
        }

        //背景绘制

    }, {
        key: 'backdropPaint',
        value: function backdropPaint() {
            this.chartList.forEach(function (scener) {});
        }

        //前景绘制

    }, {
        key: 'foregroundPaint',
        value: function foregroundPaint() {
            var _this2 = this;

            this.chartList.forEach(function (chart) {
                chart.foregroundPaint();
            });

            //此处计算 this.interval


            //释放鼠标点击坐标点
            if (!this.clickEventQueue.isEmpty()) this.clickEventQueue.dequeue();

            //释放鼠标移动坐标点
            if (!this.mousemoveEventQueue.isEmpty()) this.mousemoveEventQueue.dequeue();

            //DOMHighResTimeStamp 是一个double类型，用于存储时间值。该值可以是离散的时间点或两个离散时间点之间的时间差，单位为毫秒
            (0, _render2.default)(function (iDOMHighResTimeStamp) {
                //计算每次绘制的时间间隔
                _this2.interval = iDOMHighResTimeStamp - lastIDOMHighResTimeStamp;
                lastIDOMHighResTimeStamp = iDOMHighResTimeStamp;
                _this2.foregroundPaint();
            });
        }

        //开始绘制

    }, {
        key: 'startPaint',
        value: function startPaint() {
            var _this3 = this;

            (0, _render2.default)(function (iDOMHighResTimeStamp) {

                //计算每次绘制的时间间隔
                _this3.interval = iDOMHighResTimeStamp - lastIDOMHighResTimeStamp;
                lastIDOMHighResTimeStamp = iDOMHighResTimeStamp;

                //背景只绘制一次
                _this3.backdropPaint();

                //前景一般需要重复绘制
                _this3.foregroundPaint();
            });
        }
    }]);

    return Stage;
}();

exports.default = Stage;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//场景
var Scene = function () {
    function Scene(stage2d, canvas) {
        _classCallCheck(this, Scene);

        //场景对应的舞台
        this.stage2d = stage2d;

        this.width = stage2d.width;

        this.height = stage2d.height;

        //场景画布对象
        this.canvas = canvas;

        //绘图对象
        this.context = canvas.getContext('2d');
    }

    _createClass(Scene, [{
        key: 'paint',
        value: function paint(callback) {
            //清理画面
            this.context.clearRect(0, 0, this.width, this.height);

            //重置画布的透明度
            this.context.globalAlpha = 1;

            this.context.save();

            //重新设定画布偏移和缩放
            this.context.translate(this.stage2d.translateX, this.stage2d.translateY);

            // console.log("this.scale", this.scale);
            this.context.scale(this.stage2d.scale, this.stage2d.scale);

            //需要重复绘制的内容
            callback(this.context);

            this.context.restore();
        }
    }], [{
        key: 'init',
        value: function init(stage2d, index) {

            //创建 Canvas，并添加到场景
            var canvas = document.createElement('canvas');
            canvas.width = stage2d.width;
            canvas.height = stage2d.height;
            canvas.style.position = 'absolute';

            stage2d.container.appendChild(canvas);

            return new Scene(stage2d, canvas);
        }
    }]);

    return Scene;
}();

exports.default = Scene;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//事件对象
var Event2d = function Event2d(event, callback) {
    _classCallCheck(this, Event2d);

    //事件类型
    this.eventType = event;

    //事件回调
    this.callback = callback;
};

exports.default = Event2d;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Pie = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _render = __webpack_require__(1);

var _render2 = _interopRequireDefault(_render);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//图形基类
var Shape = function () {
    function Shape() {
        _classCallCheck(this, Shape);

        this.recoverAnimateIng = false;
    }

    //过渡动画


    _createClass(Shape, [{
        key: 'animate',
        value: function animate(option) {
            var _this = this;

            var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;


            //属性原始值
            var originalValues = {};

            //属性变化量
            var changeValues = {};

            for (var key in option) {
                if (key === 'eAngle') {
                    originalValues[key] = this[key] * 100;
                    changeValues[key] = option[key] * 100 - originalValues[key];
                } else {
                    originalValues[key] = this[key];
                    changeValues[key] = option[key] - this[key];
                }
            }

            var time = 0;

            var durationTime = speed / 1000;

            var step = function step() {

                time = time + _this.stage2d.interval;

                if (time > speed) {
                    time = speed;
                }

                for (var _key in changeValues) {

                    if (_key === 'eAngle') {
                        //通过缓动函数求出某一属性在时间轴上对应的过度值
                        _this[_key] = _this.easeOut(time / 1000, originalValues[_key], changeValues[_key], durationTime) / 100;
                    } else {
                        //通过缓动函数求出某一属性在时间轴上对应的过度值
                        _this[_key] = _this.easeOut(time / 1000, originalValues[_key], changeValues[_key], durationTime);
                    }

                    // console.table([
                    //     {
                    //         time,
                    //         originalValue: originalValues[key],
                    //         changeValue: changeValues[key],
                    //         speed,
                    //         value: this[key],
                    //         eAngel: option[key] * 100
                    //     }
                    // ])
                }

                if (time < speed) {
                    (0, _render2.default)(step);
                }
            };

            (0, _render2.default)(step);
        }

        /*!
         * [easeOut 缓动函数]
         * @param  {[float]} t:timestamp [动画执行到当前帧所经过的时间] 如：0.3s
         * @param  {[float]} b:begining [起始值] 如：10
         * @param  {[float]} c:change [需要变化的量] 如：从 10 到 100，变化量是 90
         * @param  {[float]} d:duration [动画从开始到结束的总时长] 如：0.4s
         * @return {[float]}   [description] 时间轴上对应的过度值
         */

    }, {
        key: 'easeOut',
        value: function easeOut(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        }
    }]);

    return Shape;
}();

//饼状图


var Pie = exports.Pie = function (_Shape) {
    _inherits(Pie, _Shape);

    function Pie() {
        _classCallCheck(this, Pie);

        //类型
        var _this2 = _possibleConstructorReturn(this, (Pie.__proto__ || Object.getPrototypeOf(Pie)).call(this));

        _this2.type = 'pie';

        //形状的初始X坐标
        _this2.originalX = 0;

        //形状的初始Y坐标
        _this2.originalY = 0;

        //形状的X坐标
        _this2.x = 0;

        //形状的Y坐标
        _this2.y = 0;

        //填充颜色或图案
        _this2.pattern = '#ffffff';

        //填充颜色或图案 mouseover
        _this2.mouseOverPattern = '#ffffff';

        //名称
        _this2.name = '';

        //值
        _this2.value = 0;

        //半径
        _this2.radius = 0;

        //百分比
        _this2.precent = 0;

        //起始角，以弧度计
        _this2.sAngle = 0;

        //结束角，以弧度计
        _this2.eAngle = 0;

        //动画变化量
        //changeValue = {}

        //动画时间轴
        //this.time = 0

        return _this2;
    }

    //绘制饼形


    _createClass(Pie, [{
        key: 'paintPie',
        value: function paintPie(context) {

            context.beginPath();

            //对于饼状图，xy是圆的中心
            context.moveTo(this.x, this.y);

            context.arc(this.x, this.y, this.radius, this.sAngle, this.eAngle);

            context.closePath();

            if (context.isPointInPath(this.stage2d.mouseX, this.stage2d.mouseY)) {
                context.fillStyle = this.mouseOverPattern;
                this.eventDetection();
            } else {
                context.fillStyle = this.pattern;
            }

            // let radian = (this.eAngle - this.sAngle) / 2 + this.sAngle  - (1.5 * Math.PI)
            // let x = this.x + Math.sin(radian) * (this.radius + 10)
            // let y = this.y - Math.cos(radian) * (this.radius + 10)

            context.stroke();
            context.fill();

            // context.beginPath()
            // context.arc(x, y, 5, 0, 2*Math.PI)
            // context.closePath()
            //
            // context.stroke()
            // context.fill()

        }

        //鼠标事件检测

    }, {
        key: 'eventDetection',
        value: function eventDetection() {

            var eventList = this.chart2d.eventList;

            if (eventList.length > 0) {
                //遍历事件列表，以响应多个事件
                for (var i in eventList) {
                    switch (eventList[i].eventType) {
                        case 'click':
                            //检测点击事件
                            var clickEventQueue = this.stage2d.clickEventQueue;

                            //如果点击事件队列不为空，执行回调，并消耗一次点击坐标
                            if (!clickEventQueue.isEmpty()) {
                                eventList[i].callback(this.getEventData(clickEventQueue.dequeue()));
                                //先复原，然后播放点击动画,
                                this.chart2d.recoverAnimate();
                                if (this.recoverAnimateIng) {
                                    this.recoverAnimateIng = false;
                                } else {
                                    this.clickAnimate();
                                }
                            }

                            break;
                        default:

                    }
                }
            }
        }
    }, {
        key: 'getEventData',
        value: function getEventData(point) {
            return {
                mouseX: this.stage2d.mouseX,
                mouseY: this.stage2d.mouseY,
                name: this.name,
                value: this.value,
                precent: this.precent
            };
        }

        //点击动画

    }, {
        key: 'clickAnimate',
        value: function clickAnimate() {

            //计算饼形中线弧度
            var radian = (this.eAngle - this.sAngle) / 2 + this.sAngle + 0.5 * Math.PI;

            //计算移动后的圆心坐标
            var x = this.x + Math.sin(radian) * 10;
            var y = this.y - Math.cos(radian) * 10;

            //先记录当前 shape 和圆心坐标，复原时用
            this.chart2d.addRecoverAnimate(this, {
                x: this.x,
                y: this.y
            });

            //开始播放移动动画
            this.animate({
                x: x,
                y: y
            });

            this.recoverAnimateIng = true;
        }

        //绘制名称

    }, {
        key: 'paintName',
        value: function paintName(context, stage2d) {}

        //绘制数据值

    }, {
        key: 'paintValue',
        value: function paintValue(context) {}
    }, {
        key: 'paint',
        value: function paint(context) {

            //保存画布句柄，开始绘制饼形
            context.save();
            this.paintPie(context);
            context.restore();

            //计算饼形中线弧度
            var radian = (this.eAngle - this.sAngle) / 2 + this.sAngle + 0.5 * Math.PI;

            //绘制数据值
            var x = this.x + Math.sin(radian) * (this.radius * .7);
            var y = this.y - Math.cos(radian) * (this.radius * .7);
            context.fillText(this.precent + '%', x, y);

            //开始绘制名称，计算名称指引线开始坐标(sx, xy)和结束(ex, ey)坐标
            var sx = this.originalX + Math.sin(radian) * (this.radius + 4);
            var sy = this.originalY - Math.cos(radian) * (this.radius + 4);
            var ex = this.originalX + Math.sin(radian) * (this.radius + 20);
            var ey = this.originalY - Math.cos(radian) * (this.radius + 20);

            //保存画布句柄，开始画线
            context.save();

            context.strokeStyle = this.pattern;
            context.beginPath();
            context.moveTo(sx, sy);
            context.lineTo(ex, ey);
            context.stroke();

            //绘制名称

            if (radian < Math.PI) {
                context.textAlign = "left";
            } else {
                context.textAlign = "right";
            }
            context.fillStyle = "#222222";
            context.fillStyle = this.pattern;
            context.fillText(this.name + '：' + this.precent + '%', ex, ey);
            context.restore();
        }
    }]);

    return Pie;
}(Shape);

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Queue = function () {
    function Queue(stage2d, canvas) {
        _classCallCheck(this, Queue);

        this.items = [];
    }

    //向队列尾部添加一个新的项


    _createClass(Queue, [{
        key: "enqueue",
        value: function enqueue(element) {
            this.items.push(element);
        }

        //从队列中取出一个元素，并返回该元素

    }, {
        key: "dequeue",
        value: function dequeue() {
            return this.items.shift();
        }

        //查看队列最前面的元素

    }, {
        key: "front",
        value: function front() {
            return this.items[0];
        }

        //查看队列是否为空，如果为空，返回true；否则返回false

    }, {
        key: "isEmpty",
        value: function isEmpty() {
            return this.items.length == 0;
        }

        //查看队列的长度

    }, {
        key: "size",
        value: function size() {
            return this.items.length;
        }
    }]);

    return Queue;
}();

exports.default = Queue;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//鼠标按下事件
var EVENT_MOUSE_DOWN = exports.EVENT_MOUSE_DOWN = "EVENT_MOUSE_DOWN";

//鼠标移动事件
var EVENT_MOUSE_MOVE = exports.EVENT_MOUSE_MOVE = "EVENT_MOUSE_MOVE";

//鼠标松开事件
var EVENT_MOUSE_UP = exports.EVENT_MOUSE_UP = "EVENT_MOUSE_UP";

//鼠标松开事件
var EVENT_MOUSE_SCROLL = exports.EVENT_MOUSE_SCROLL = "EVENT_MOUSE_SCROLL";

/***/ })
/******/ ]);